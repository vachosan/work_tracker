{% extends "tracker/base.html" %}
{% load static %}
{% block title %}MapLibre Pilot{% endblock %}
{% block content %}
<link rel="stylesheet" href="{% static 'css/map_ui.css' %}">
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css">
<style>
  html, body { height: 100%; overflow: hidden; }
  body { margin: 0; background: #000; }
  nav.navbar,
  footer { display: none !important; }
  main.container { padding: 0 !important; max-width: none; }
  #map {
    position: fixed;
    inset: 0;
    z-index: 1;
  }
  #wr-label-overlay {
    position: fixed;
    inset: 0;
    z-index: 2;
    pointer-events: none;
    font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
  }
  .wr-label {
    position: absolute;
    font-size: 0.85rem;
    font-weight: 600;
    color: #111;
    text-shadow:
      0 0 4px rgba(255, 255, 255, 0.95),
      0 0 8px rgba(255, 255, 255, 0.75);
    white-space: nowrap;
    will-change: transform;
  }
</style>

<div id="map"></div>
<div id="wr-label-overlay"></div>

{% include "tracker/partials/map_ui.html" %}

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script>
  window.workTrackerMapUiConfig = {
    workRecordDetailApiBase: "{% url 'workrecord_detail_api' 0 %}".replace(/0\/?$/, ""),
    assessmentApiBase: "{% url 'workrecord_assessment_api' 0 %}".replace("0/assessment/", ""),
    mapUploadPhotoUrl: "{% url 'map_upload_photo' %}",
    projectId: "{{ request.GET.project|default:'' }}",
    addToProjectUrlTemplate: "{% url 'project_tree_add' 0 0 %}",
    csrfToken: "{{ csrf_token }}",
    interventionNoteData: {{ intervention_note_data_json|default:"{}" | safe }},
  };
  {% if request.GET.debug_map_ui %}
  window.DEBUG_MAP_UI = true;
  {% else %}
  window.DEBUG_MAP_UI = false;
  {% endif %}
</script>
{{ projects_js|json_script:"projects-data" }}
<script src="{% static 'js/map_ui.js' %}?v=dev1"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
    if (!window.maplibregl) {
      console.error('MapLibre GL JS is not available.');
      return;
    }

    const API_KEY = "{{ mapy_key|default:'' }}";
    const WORKRECORDS_GEOJSON_URL = "{% url 'workrecords_geojson' %}";
    const MAP_CREATE_RECORD_URL = "{% url 'map_create_work_record' %}";
    const CSRF_TOKEN = "{{ csrf_token }}";
    const taxonSuggestUrl = "{% url 'gbif_taxon_suggest' %}";
    const LABEL_MIN_ZOOM = 17;
    const LABEL_LIMIT = 200;
    const CONTEXT_ZOOM = 18;
    const CONTEXT_SOURCE_ID = 'workrecords-context';
    const CONTEXT_LAYER_ID = 'workrecords-context-points';
    const CROWN_SOURCE_ID = 'tree_crowns';
    const CROWN_FILL_LAYER_ID = 'tree_crowns_fill';
    const CROWN_LINE_LAYER_ID = 'tree_crowns_line';
    const labelOverlay = document.getElementById('wr-label-overlay');
    // Cache DOM nodes by feature id to avoid duplicate label elements.
    const labelNodeCache = new Map();
    let workrecordFeatures = [];
    let workrecordFeatureCollection = null;
    let contextFeatures = [];
    let selectedLat = null;
    let selectedLon = null;
    let newRecordCoords = null;
    let pendingFocusId = null;
    const WORKRECORD_POINT_RADIUS = 5;
    const WORKRECORD_POINT_STROKE_WIDTH = 1;
    const WORKRECORD_POINT_STROKE_COLOR = '#fff';
    const WORKRECORD_POINT_OPACITY = 1;
    const PROJECT_POINT_COLOR = '#f97316';
    const CONTEXT_POINT_COLOR = '#888';
    const CONTEXT_POINT_OPACITY = 0.7;
    const CROWN_DIAMETER_KEYS = ['crown_diameter_m', 'crown_width_m', 'diameter_crown', 'crown_diameter'];
    const CROWN_STEPS = 64;
    const WORKRECORDS_DEBOUNCE_MS = 200;
    // DEBUG_FETCH = true logs workrecords/context fetch URL + bbox, feature counts, and aborts.
    const DEBUG_FETCH = false;

    const toNumber = (value) => {
      if (value === null || value === '') return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };
    const parseFloatWithComma = (value) => {
      if (value === null || value === '') return null;
      const normalized = String(value).replace(',', '.');
      const num = Number(normalized);
      return Number.isFinite(num) ? num : null;
    };
    const logFetchDebug = (...args) => {
      if (!DEBUG_FETCH) return;
      if (console && console.debug) {
        console.debug(...args);
      }
    };
    const params = new URLSearchParams(window.location.search);
    const projectParam = params.get('project');
    const dataParams = new URLSearchParams();
    if (projectParam) {
      dataParams.set('project', projectParam);
    }
    const WORKRECORDS_GEOJSON_URL_WITH_PARAMS = dataParams.toString()
      ? `${WORKRECORDS_GEOJSON_URL}?${dataParams.toString()}`
      : WORKRECORDS_GEOJSON_URL;
    const initialLat = parseFloatWithComma(params.get('lat'));
    const initialLon = parseFloatWithComma(params.get('lon'));
    const initialZoom = toNumber(params.get('z'));
    const focusParam = toNumber(params.get('focus'));
    pendingFocusId = Number.isFinite(focusParam) ? focusParam : null;
    let initialBbox = null;
    const bboxParam = params.get('bbox');
    if (bboxParam) {
      const parts = bboxParam.split(',').map(toNumber);
      if (parts.length === 4 && parts.every((p) => p !== null)) {
        initialBbox = parts;
      }
    }
    const clearFocusParam = () => {
      if (!params.has('focus')) return;
      params.delete('focus');
      const qs = params.toString();
      const nextUrl = window.location.pathname + (qs ? `?${qs}` : '') + window.location.hash;
      window.history.replaceState({}, '', nextUrl);
    };

    const newRecordModal = document.getElementById('newRecordModal');
    const newRecordTitleInput = document.getElementById('newRecordTitle');
    const newRecordSaveBtn = document.getElementById('newRecordSaveBtn');
    const newRecordCancelBtn = document.getElementById('newRecordCancelBtn');
    const newRecordCloseBtn = document.getElementById('newRecordCloseBtn');
    const createFab = document.getElementById('createFab');
    const projectSelect = document.getElementById('projectSelect');
    const taxonDisplayInput = document.getElementById('taxon_display');
    const taxonCzechInput = document.getElementById('taxon_czech');
    const taxonLatinInput = document.getElementById('taxon_latin');
    const taxonGbifKeyInput = document.getElementById('taxon_gbif_key');
    const taxonSuggestionsList = document.getElementById('taxon-suggestions');
    const taxonFieldWrapper = document.getElementById('taxon-field-wrapper');

    function hideTaxonSuggestions() {
      if (!taxonSuggestionsList) return;
      taxonSuggestionsList.classList.remove('visible');
      taxonSuggestionsList.innerHTML = '';
    }

    function renderTaxonSuggestions(items) {
      if (!taxonSuggestionsList) return;
      taxonSuggestionsList.innerHTML = '';
      if (!items.length) {
        hideTaxonSuggestions();
        return;
      }
      items.forEach(item => {
        const li = document.createElement('li');
        const label = item.display || item.scientific_name || item.vernacular_name || '';
        li.textContent = label;
        li.className = 'list-group-item list-group-item-action';
        li.addEventListener('click', () => {
          if (taxonDisplayInput) taxonDisplayInput.value = label;
          if (taxonCzechInput) taxonCzechInput.value = item.vernacular_name || '';
          if (taxonLatinInput) taxonLatinInput.value = item.scientific_name || '';
          if (taxonGbifKeyInput) taxonGbifKeyInput.value = item.gbif_key || '';
          hideTaxonSuggestions();
        });
        taxonSuggestionsList.appendChild(li);
      });
      taxonSuggestionsList.classList.add('visible');
    }

    function requestTaxonSuggestions(query) {
      if (!taxonSuggestUrl || !query || query.length < 2) {
        hideTaxonSuggestions();
        return;
      }
      fetch(`${taxonSuggestUrl}?q=${encodeURIComponent(query)}`)
        .then(resp => resp.ok ? resp.json() : Promise.resolve({ results: [] }))
        .then(data => {
          renderTaxonSuggestions((data && data.results) || []);
        })
        .catch(() => hideTaxonSuggestions());
    }

    if (taxonDisplayInput) {
      taxonDisplayInput.addEventListener('input', () => {
        const value = taxonDisplayInput.value.trim();
        if (value.length < 2) {
          hideTaxonSuggestions();
          return;
        }
        requestTaxonSuggestions(value);
      });
      taxonDisplayInput.addEventListener('focus', () => {
        if (taxonSuggestionsList && taxonSuggestionsList.childElementCount) {
          taxonSuggestionsList.classList.add('visible');
        }
      });
    }

    document.addEventListener('click', (event) => {
      if (taxonFieldWrapper && !taxonFieldWrapper.contains(event.target)) {
        hideTaxonSuggestions();
      }
    });

    function resetNewRecordForm() {
      if (newRecordTitleInput) newRecordTitleInput.value = '';
      if (taxonDisplayInput) taxonDisplayInput.value = '';
      if (taxonCzechInput) taxonCzechInput.value = '';
      if (taxonLatinInput) taxonLatinInput.value = '';
      if (taxonGbifKeyInput) taxonGbifKeyInput.value = '';
      hideTaxonSuggestions();
    }

    function openNewRecordModal() {
      if (!newRecordModal) return;
      newRecordModal.classList.add('active');
    }

    function closeNewRecordModal() {
      if (!newRecordModal) return;
      newRecordModal.classList.remove('active');
      hideTaxonSuggestions();
    }

    if (newRecordCancelBtn) {
      newRecordCancelBtn.addEventListener('click', closeNewRecordModal);
    }
    if (newRecordCloseBtn) {
      newRecordCloseBtn.addEventListener('click', closeNewRecordModal);
    }
    if (newRecordModal) {
      newRecordModal.addEventListener('click', (e) => {
        if (e.target === newRecordModal) {
          closeNewRecordModal();
        }
      });
    }

    function updateNewRecordMarker(lngLat) {
      newRecordCoords = [lngLat.lng, lngLat.lat];
      const source = map.getSource('new-record-point');
      if (!source) return;
      source.setData({
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: newRecordCoords },
            properties: {},
          },
        ],
      });
    }

    function clearNewRecordMarker() {
      const source = map.getSource('new-record-point');
      if (source) {
        source.setData({ type: 'FeatureCollection', features: [] });
      }
      newRecordCoords = null;
    }

    function submitNewRecord() {
      if (!newRecordSaveBtn) return;
      if (selectedLat === null || selectedLon === null) {
        alert('Nejdřív klikni do mapy a vyber bod.');
        return;
      }
      const urlParams = new URLSearchParams(window.location.search);
      const projectIdParam = urlParams.get('project');
      const title = newRecordTitleInput ? newRecordTitleInput.value.trim() : '';
      const displayTaxon = taxonDisplayInput ? taxonDisplayInput.value.trim() : '';
      const latinTaxon = taxonLatinInput ? taxonLatinInput.value.trim() : '';
      const czechTaxon = taxonCzechInput ? taxonCzechInput.value.trim() : '';
      const gbifKeyValue = taxonGbifKeyInput ? taxonGbifKeyInput.value.trim() : '';
      const projectId = projectSelect ? projectSelect.value : '';
      const taxonValue = latinTaxon || displayTaxon;

      newRecordSaveBtn.disabled = true;
      const payload = new URLSearchParams({
        title: title,
        taxon: taxonValue,
        taxon_czech: czechTaxon,
        taxon_latin: latinTaxon,
        taxon_gbif_key: gbifKeyValue,
        date: '',
        project_id: projectId && projectId !== 'none' ? projectId : '',
        latitude: selectedLat,
        longitude: selectedLon,
      });
      if (projectIdParam) {
        payload.set('project', projectIdParam);
      }
      const requestUrl = projectIdParam
        ? `${MAP_CREATE_RECORD_URL}?project=${encodeURIComponent(projectIdParam)}`
        : MAP_CREATE_RECORD_URL;
      if (console && console.debug) {
        console.debug('map-create projectId', projectIdParam);
        console.debug('map-create requestUrl', requestUrl);
        console.debug('map-create payload has project', payload.has('project'));
      }

      fetch(requestUrl, {
        method: 'POST',
        headers: {
          'X-CSRFToken': CSRF_TOKEN,
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: payload.toString(),
      })
        .then(resp => resp.json())
        .then(data => {
          if (data.status === 'ok' && data.record) {
            resetNewRecordForm();
            closeNewRecordModal();
            clearNewRecordMarker();
            selectedLat = null;
            selectedLon = null;
            const rec = data.record;
            const label = rec.external_tree_id || rec.title || `WR ${rec.id}`;
            const feature = {
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [rec.lon, rec.lat] },
              properties: { id: rec.id, label },
            };
            workrecordFeatures.push({ id: rec.id, label, coordinates: [rec.lon, rec.lat] });
            if (!workrecordFeatureCollection) {
              workrecordFeatureCollection = { type: 'FeatureCollection', features: [] };
            }
            workrecordFeatureCollection.features.push(feature);
            const src = map.getSource('workrecords');
            if (src && typeof src.setData === 'function') {
              src.setData(workrecordFeatureCollection);
            }
            updateTreeCrownsSource(workrecordFeatureCollection);
            renderLabelOverlay();
            if (window.openWorkRecordPanel) {
              window.openWorkRecordPanel(data.record.id);
            }
          } else {
            alert(data.msg || 'Nepodařilo se uložit strom.');
          }
        })
        .catch(() => {
          alert('Chyba při ukládání stromu.');
        })
        .finally(() => {
          newRecordSaveBtn.disabled = false;
        });
    }

    if (newRecordSaveBtn) {
      newRecordSaveBtn.addEventListener('click', submitNewRecord);
    }

    if (createFab) {
      createFab.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!newRecordCoords) {
          alert('Nejdřív vyber místo kliknutím do mapy.');
          return;
        }
        openNewRecordModal();
      });
    }
    const sanitizeUrl = (value) => {
      if (typeof value !== 'string') return value;
      const [base] = value.split('?');
      return base;
    };
    const sanitizeErrorValue = (value) => {
      if (!value) return value;
      if (typeof value === 'string') {
        return value.replace(/([?&])apikey=[^&]+/gi, '$1apikey=***');
      }
      if (typeof value === 'object') {
        const clone = Array.isArray(value) ? [...value] : { ...value };
        if (clone.url) clone.url = sanitizeUrl(clone.url);
        if (clone.resource && typeof clone.resource === 'object' && clone.resource.url) {
          clone.resource = { ...clone.resource, url: sanitizeUrl(clone.resource.url) };
        }
        return clone;
      }
      return value;
    };

    const getCrownDiameterM = (properties) => {
      if (!properties) return null;
      for (const key of CROWN_DIAMETER_KEYS) {
        const value = toNumber(properties[key]);
        if (value && value > 0) return value;
      }
      return null;
    };

    const crownsToGeoJSON = (pointsGeoJSON) => {
      const empty = { type: 'FeatureCollection', features: [] };
      if (!pointsGeoJSON || pointsGeoJSON.type !== 'FeatureCollection') return empty;
      if (!window.turf || typeof window.turf.circle !== 'function') return empty;
      const features = [];
      for (const feature of pointsGeoJSON.features || []) {
        if (!feature || !feature.geometry || feature.geometry.type !== 'Point') continue;
        const coords = feature.geometry.coordinates;
        if (!Array.isArray(coords) || coords.length < 2) continue;
        const crownDiameterM = getCrownDiameterM(feature.properties);
        if (!crownDiameterM) continue;
        const radiusKm = (crownDiameterM / 2) / 1000;
        // Use polygons so MapLibre can render a crown radius in meters.
        const circle = window.turf.circle([coords[0], coords[1]], radiusKm, {
          steps: CROWN_STEPS,
          units: 'kilometers',
        });
        circle.properties = {
          id: feature.properties && feature.properties.id,
          crown_diameter_m: crownDiameterM,
        };
        features.push(circle);
      }
      return { type: 'FeatureCollection', features };
    };

    const updateTreeCrownsSource = (pointsGeoJSON) => {
      const source = map.getSource(CROWN_SOURCE_ID);
      if (!source || typeof source.setData !== 'function') return;
      source.setData(crownsToGeoJSON(pointsGeoJSON));
    };

    const cuzkOrthoTiles = 'https://ags.cuzk.gov.cz/arcgis1/rest/services/ORTOFOTO_WM/MapServer/tile/{z}/{y}/{x}';
    // CUZK services: WMS/WMTS/WFS INSPIRE CP -> https://services.cuzk.gov.cz/
    const CUZK_KATASTR_WMS_BASE = 'https://services.cuzk.gov.cz/wms/wms.asp?';
    // Layer name verified in GetCapabilities: https://services.cuzk.gov.cz/wms/wms.asp?service=WMS&request=GetCapabilities
    const CUZK_KATASTR_LAYER_NAME = 'KN';
    const CUZK_KATASTR_OPACITY = 0.6;
    // TODO: Future parcel data hook (INSPIRE CP WFS).
    // Endpoint: https://services.cuzk.gov.cz/wfs/inspire-cp-wfs.asp
    // Output is GML; plan server-side conversion to GeoJSON + DB caching.

    const style = {
      version: 8,
      // Glyph coverage is provided by OpenMapTiles' hosted fonts endpoint
      glyphs: 'https://fonts.openmaptiles.org/{fontstack}/{range}.pbf',
      sources: {
        'cuzk-ortho': {
          type: 'raster',
          tiles: [cuzkOrthoTiles],
          tileSize: 256,
          minzoom: 6,
          maxzoom: 20,
          attribution: '&copy; CUZK',
        },
        'cz-labels': {
          type: 'vector',
          url: 'pmtiles:///tiles/cz.pmtiles',
          maxzoom: 14,
          attribution: '© OpenMapTiles © OpenStreetMap contributors',
        },
        'cuzk-katastr': {
          type: 'raster',
          tiles: [
            `${CUZK_KATASTR_WMS_BASE}service=WMS&request=GetMap&version=1.3.0&layers=${CUZK_KATASTR_LAYER_NAME}&styles=&format=image/png&transparent=true&width=256&height=256&crs=EPSG:3857&bbox={bbox-epsg-3857}`,
          ],
          tileSize: 256,
          minzoom: 6,
          maxzoom: 20,
          attribution: '&copy; CUZK',
        },
      },
      layers: [
        {
          id: 'background',
          type: 'background',
          paint: { 'background-color': '#dde6f1' },
        },
        {
          id: 'cuzk-ortho',
          type: 'raster',
          source: 'cuzk-ortho',
        },
        {
          id: 'cuzk-katastr',
          type: 'raster',
          source: 'cuzk-katastr',
          paint: { 'raster-opacity': CUZK_KATASTR_OPACITY },
          layout: { visibility: 'none' },
        },
      ],
    };

    const streetNamesCheckbox = document.getElementById('streetNamesCheckbox');
    const katastrCheckbox = document.getElementById('katastrCheckbox');
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol('pmtiles', protocol.tile);
    const map = new maplibregl.Map({
      container: 'map',
      style,
      center: [17.2509, 49.5938], // Olomouc
      zoom: 13,
    });
    const applyInitialView = () => {
      if (initialLat !== null && initialLon !== null) {
        // lat/lon deep-link has priority over bbox
        map.flyTo({
          center: [initialLon, initialLat],
          zoom: initialZoom !== null ? initialZoom : 18,
          duration: 800,
        });
        return;
      }
      if (initialBbox) {
        const [minLon, minLat, maxLon, maxLat] = initialBbox;
        map.fitBounds([[minLon, minLat], [maxLon, maxLat]], {
          padding: 40,
          duration: 800,
        });
      }
    };
    const focusWorkRecordById = (recordId) => {
      if (!recordId) return false;
      const target = workrecordFeatures.find((feature) => Number(feature.id) === Number(recordId));
      if (!target) {
        if (window.openWorkRecordPanel) {
          window.openWorkRecordPanel(recordId);
          return true;
        }
        return false;
      }
      map.easeTo({
        center: target.coordinates,
        zoom: Math.max(map.getZoom(), 18),
        duration: 600,
      });
      if (window.openWorkRecordPanel) {
        window.openWorkRecordPanel(target.id, { label: target.label });
      }
      return true;
    };
    const applyInitialFocus = () => {
      if (!pendingFocusId) return;
      focusWorkRecordById(pendingFocusId);
      pendingFocusId = null;
      clearFocusParam();
    };
    const buildContextUrl = () => {
      const bounds = map.getBounds && map.getBounds();
      if (!bounds) return null;
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();
      if (!sw || !ne) return null;
      const bbox = `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`;
      return `${WORKRECORDS_GEOJSON_URL}?bbox=${encodeURIComponent(bbox)}`;
    };
    const formatCoord = (value) => {
      if (!Number.isFinite(value)) return null;
      return Number(value.toFixed(6));
    };

    const buildWorkrecordsUrl = () => {
      const bounds = map.getBounds && map.getBounds();
      if (!bounds) return WORKRECORDS_GEOJSON_URL_WITH_PARAMS;
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();
      if (!sw || !ne) return WORKRECORDS_GEOJSON_URL_WITH_PARAMS;
      // MapLibre bounds are in WGS84 degrees (lon/lat).
      if (sw.lng > ne.lng) {
        // Antimeridian crossing - skip bbox to avoid sending an invalid extent.
        return WORKRECORDS_GEOJSON_URL_WITH_PARAMS;
      }
      const bboxValues = [
        formatCoord(sw.lng),
        formatCoord(sw.lat),
        formatCoord(ne.lng),
        formatCoord(ne.lat),
      ];
      if (bboxValues.some((value) => value === null)) {
        return WORKRECORDS_GEOJSON_URL_WITH_PARAMS;
      }
      const bbox = bboxValues.join(',');
      const baseUrl = new URL(WORKRECORDS_GEOJSON_URL_WITH_PARAMS, window.location.origin);
      baseUrl.searchParams.set('bbox', bbox);
      return baseUrl.toString();
    };
    let contextRefreshTimer = null;
    const refreshContextSource = () => {
      if (!projectParam) return;
      const source = map.getSource(CONTEXT_SOURCE_ID);
      if (!source) return;
      const zoom = map.getZoom();
      if (!Number.isFinite(zoom) || zoom < CONTEXT_ZOOM) {
        if (map.getLayer(CONTEXT_LAYER_ID)) {
          map.setLayoutProperty(CONTEXT_LAYER_ID, 'visibility', 'none');
        }
        if (contextFeatures.length) {
          contextFeatures = [];
          renderLabelOverlay();
        }
        return;
      }
      const url = buildContextUrl();
      if (!url) return;
      if (map.getLayer(CONTEXT_LAYER_ID)) {
        map.setLayoutProperty(CONTEXT_LAYER_ID, 'visibility', 'visible');
      }
        fetch(url)
          .then(resp => resp.json())
          .then(fc => {
            const features = Array.isArray(fc && fc.features) ? fc.features : [];
            contextFeatures = features
            .map(feature => {
              if (!feature || !feature.geometry || !feature.properties) return null;
              const coords = feature.geometry.coordinates;
              if (!Array.isArray(coords) || coords.length < 2) return null;
              return {
                id: feature.properties.id,
                label: feature.properties.label,
                coordinates: coords,
              };
            })
            .filter(Boolean);
            source.setData(fc);
            renderLabelOverlay();
          })
          .catch(err => logFetchDebug('context fetch error', err));
    };
    const scheduleContextRefresh = () => {
      if (!projectParam) return;
      if (contextRefreshTimer) {
        clearTimeout(contextRefreshTimer);
      }
      contextRefreshTimer = setTimeout(() => {
        refreshContextSource();
      }, 200);
    };
    let workrecordsRefreshTimer = null;
    let workrecordsFetchSeq = 0;
    let workrecordsAbortController = null;
    const scheduleWorkrecordsRefresh = () => {
      if (workrecordsRefreshTimer) {
        clearTimeout(workrecordsRefreshTimer);
      }
      workrecordsRefreshTimer = setTimeout(() => {
        refreshProjectWorkrecords();
      }, WORKRECORDS_DEBOUNCE_MS);
    };

    const clearLabelOverlay = () => {
      if (!labelOverlay) return;
      if (typeof labelOverlay.replaceChildren === 'function') {
        labelOverlay.replaceChildren();
      } else {
        labelOverlay.innerHTML = '';
      }
      labelNodeCache.clear();
    };

    const setLayerVisibility = (layerId, visible) => {
      if (!map.getLayer(layerId)) return;
      map.setLayoutProperty(layerId, 'visibility', visible ? 'visible' : 'none');
    };

    const renderLabelOverlay = () => {
      if (!labelOverlay) {
        return;
      }
      const zoom = map.getZoom();
      if (Number.isFinite(zoom) && zoom < LABEL_MIN_ZOOM) {
        clearLabelOverlay();
        return;
      }
      const bounds = map.getBounds();
      const fragment = document.createDocumentFragment();
      let rendered = 0;
      const activeIds = new Set();
      const buildLabelNodes = (features, maxCount) => {
        const nodes = [];
        let count = 0;
        for (const feature of features) {
          if (!feature) continue;
          const coords = feature.coordinates;
          if (!Array.isArray(coords) || coords.length < 2) continue;
          const [lng, lat] = coords;
          if (!bounds || typeof bounds.contains !== 'function' || !bounds.contains([lng, lat])) {
            continue;
          }
          const labelText = feature.label || (feature.id ? `WR ${feature.id}` : '');
          if (!labelText) continue;
          const hasId = feature.id !== null && feature.id !== undefined;
          const idKey = hasId ? String(feature.id) : null;
          if (idKey && activeIds.has(idKey)) {
            continue;
          }
          const point = map.project([lng, lat]);
          const el = idKey && labelNodeCache.has(idKey)
            ? labelNodeCache.get(idKey)
            : document.createElement('div');
          if (idKey && !labelNodeCache.has(idKey)) {
            labelNodeCache.set(idKey, el);
          }
          if (!el.classList.contains('wr-label')) {
            el.className = 'wr-label';
          }
          if (el.textContent !== labelText) {
            el.textContent = labelText;
          }
          el.style.transform = `translate(${point.x}px, ${point.y}px) translate(-50%, -130%)`;
          nodes.push(el);
          if (idKey) {
            activeIds.add(idKey);
          }
          count += 1;
          if (count >= maxCount) break;
        }
        return nodes;
      };
      const contextEnabled = Boolean(projectParam) && Number.isFinite(zoom) && zoom >= CONTEXT_ZOOM;
      const projectNodes = workrecordFeatures.length
        ? buildLabelNodes(workrecordFeatures, LABEL_LIMIT)
        : [];
      rendered += projectNodes.length;
      const remaining = Math.max(LABEL_LIMIT - rendered, 0);
      const contextNodes = contextEnabled && contextFeatures.length && remaining > 0
        ? buildLabelNodes(contextFeatures, remaining)
        : [];
      for (const node of contextNodes) {
        fragment.appendChild(node);
      }
      for (const node of projectNodes) {
        fragment.appendChild(node);
      }
      for (const [idKey, node] of labelNodeCache.entries()) {
        if (!activeIds.has(idKey)) {
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
          labelNodeCache.delete(idKey);
        }
      }
      if (typeof labelOverlay.replaceChildren === 'function') {
        labelOverlay.replaceChildren(fragment);
      } else {
        labelOverlay.innerHTML = '';
        labelOverlay.appendChild(fragment);
      }
    };

    const bindLabelOverlayHandlers = () => {
      // Guard against duplicate handler binds on soft reloads.
      map.off('move', renderLabelOverlay);
      map.off('zoom', renderLabelOverlay);
      map.off('rotate', renderLabelOverlay);
      map.on('move', renderLabelOverlay);
      map.on('zoom', renderLabelOverlay);
      map.on('rotate', renderLabelOverlay);
    };
    bindLabelOverlayHandlers();

      map.on('load', () => {
        applyInitialView();
        const pm = new window.pmtiles.PMTiles('/tiles/cz.pmtiles');
        pm.getMetadata()
          .then(md => {
            console.log('PMTiles metadata', md);
            console.log('PMTiles vector_layers', md && md.vector_layers ? md.vector_layers.map(v => v.id) : md);
          })
          .catch(err => console.warn('PMTiles metadata failed', err));
        const warnMultiFontLayers = () => {
          const layers = map.getStyle() && map.getStyle().layers;
          if (!Array.isArray(layers)) return;
          for (const layer of layers) {
            const layout = layer && layer.layout;
            const textFont = layout && layout['text-font'];
            if (Array.isArray(textFont) && textFont.length > 1) {
              console.warn('Layer has multi-font stack', layer.id, textFont);
            }
          }
        };
        warnMultiFontLayers();
        console.warn('Glyphs are served from https://fonts.openmaptiles.org/... ensure remote glyphs are reachable for labels.');
      fetch('/tiles/cz.pmtiles', { method: 'GET', headers: { Range: 'bytes=0-31' } })
        .then(r => {
          console.log('PMTiles range test', r.status, r.headers.get('accept-ranges'), r.headers.get('content-range'), r.headers.get('content-length'));
          if (r.status !== 206) {
            console.warn('Server does not support byte ranges; PMTiles will not work correctly.');
          }
        })
        .catch(e => console.warn('PMTiles range test failed', e));
      console.log('PMTiles check', {
        pmtilesLoaded: typeof window.pmtiles !== 'undefined',
        protocolRegistered: true,
        pmtilesUrl: 'pmtiles:///tiles/cz.pmtiles',
      });
      fetch('/tiles/cz.pmtiles', { method: 'HEAD' })
        .then(r => console.log('PMTiles HEAD', r.status, r.headers.get('content-type'), r.headers.get('content-length')))
        .catch(e => console.warn('PMTiles HEAD failed', e));
      fetch('https://fonts.openmaptiles.org/Open%20Sans%20Regular/0-255.pbf', { method: 'HEAD' })
        .then(r => console.log('Glyph test (Open Sans Regular 0-255)', r.status, r.headers.get('content-type'), r.headers.get('content-length')))
        .catch(e => console.warn('Glyph test failed', e));
      console.log('Map loaded');
      const coarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      const HIT_TOLERANCE = coarsePointer ? 12 : 6;

      const czLabelsSource = map.getSource('cz-labels');
      console.log('cz-labels source added', czLabelsSource);

      try {
        map.addLayer({
          id: 'cz-place-labels',
          type: 'symbol',
          source: 'cz-labels',
          'source-layer': 'place',
          minzoom: 6,
          maxzoom: 14,
          filter: [
            'match',
            ['get', 'class'],
            ['city', 'town', 'village', 'hamlet', 'suburb', 'neighbourhood'],
            true,
            false,
          ],
          layout: {
            'text-field': ['coalesce', ['get', 'name:cs'], ['get', 'name']],
            'text-size': ['interpolate', ['linear'], ['zoom'], 6, 10, 10, 12, 13, 16],
            'text-allow-overlap': false,
            'text-ignore-placement': false,
            'text-font': ['Open Sans Regular'],
          },
          paint: {
            'text-color': '#1a1a1a',
            'text-halo-color': '#ffffff',
            'text-halo-width': 2,
          },
        });
        console.log('cz-place-layer exists', !!map.getLayer('cz-place-labels'));
      } catch (e) {
        console.warn('addLayer cz-place-labels failed', e);
        console.warn('Using source-layer:', 'place');
      }

      try {
        map.addLayer({
          id: 'cz-road-labels',
          type: 'symbol',
          source: 'cz-labels',
          'source-layer': 'transportation_name',
          minzoom: 13,
          maxzoom: 20,
          layout: {
            'symbol-placement': 'line',
            'text-field': ['coalesce', ['get', 'name:cs'], ['get', 'name']],
            'text-size': ['interpolate', ['linear'], ['zoom'], 13, 11, 16, 13, 18, 15],
            'text-keep-upright': true,
            'text-font': ['Open Sans Regular'],
          },
          paint: {
            'text-halo-color': 'rgba(255, 255, 255, 0.9)',
            'text-halo-width': 2,
          },
        });
        console.log('cz-road-layer exists', !!map.getLayer('cz-road-labels'));
      } catch (e) {
        console.warn('addLayer cz-road-labels failed', e);
        console.warn('Using source-layer:', 'transportation_name');
      }

      setTimeout(() => {
        try {
          const candidates = ['place', 'transportation_name', 'transportation', 'road', 'roads', 'labels', 'poi', 'name'];
          const results = {};
          for (const layer of candidates) {
            let count = 0;
            try {
              const feats = map.querySourceFeatures('cz-labels', { sourceLayer: layer });
              count = feats ? feats.length : 0;
            } catch (e) {
              results[layer] = 'ERR';
              continue;
            }
            results[layer] = count;
          }
          console.log('cz-labels querySourceFeatures counts', results);
        } catch (e) {
          console.warn('cz-labels querySourceFeatures failed', sanitizeErrorValue(e));
        }
      }, 1000);

      const applyStreetNamesVisibility = () => {
        const visible = !streetNamesCheckbox || streetNamesCheckbox.checked;
        setLayerVisibility('cz-place-labels', visible);
        setLayerVisibility('cz-road-labels', visible);
      };

      applyStreetNamesVisibility();
      if (streetNamesCheckbox) {
        streetNamesCheckbox.addEventListener('change', applyStreetNamesVisibility);
      }
      const applyKatastrVisibility = () => {
        const visible = katastrCheckbox && katastrCheckbox.checked;
        setLayerVisibility('cuzk-katastr', visible);
      };
      applyKatastrVisibility();
      if (katastrCheckbox) {
        katastrCheckbox.addEventListener('change', applyKatastrVisibility);
      }

      const refreshProjectWorkrecords = () => {
        if (!map || !map.getSource('workrecords')) {
          logFetchDebug('workrecords refresh skipped (source missing)');
          scheduleWorkrecordsRefresh();
          return Promise.resolve();
        }
        const url = buildWorkrecordsUrl();
        const requestId = ++workrecordsFetchSeq;
        if (workrecordsAbortController) {
          workrecordsAbortController.abort();
          logFetchDebug('workrecords fetch aborted', { requestId: requestId - 1 });
        }
        workrecordsAbortController = new AbortController();
        logFetchDebug('workrecords fetch', { requestId, url });
        return fetch(url, { signal: workrecordsAbortController.signal })
          .then(resp => resp.json())
          .then(fc => {
            if (requestId !== workrecordsFetchSeq) {
              logFetchDebug('workrecords fetch ignored (stale)', { requestId });
              return;
            }
            const features = Array.isArray(fc && fc.features) ? fc.features : [];
            logFetchDebug('workrecords features', features.length);
            logFetchDebug('workrecords sample labels', features.slice(0, 3).map(f => f && f.properties ? f.properties.label : null));
            workrecordFeatures = features
              .map(feature => {
                if (!feature || !feature.geometry || !feature.properties) return null;
                const coords = feature.geometry.coordinates;
                if (!Array.isArray(coords) || coords.length < 2) return null;
                return {
                  id: feature.properties.id,
                  label: feature.properties.label,
                  coordinates: coords,
                };
              })
              .filter(Boolean);
            workrecordFeatureCollection = fc;
            const src = map.getSource('workrecords');
            if (src && typeof src.setData === 'function') {
              src.setData(fc);
            }
            updateTreeCrownsSource(fc);
            renderLabelOverlay();
            applyInitialFocus();
          })
          .catch(err => {
            if (err && err.name === 'AbortError') {
              logFetchDebug('workrecords fetch aborted', { requestId });
              return;
            }
            console.error('workrecords fetch error', err);
          });
      };
      window.refreshProjectWorkrecords = refreshProjectWorkrecords;

      if (projectParam) {
        map.addSource(CONTEXT_SOURCE_ID, {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] },
        });
        map.addLayer({
          id: CONTEXT_LAYER_ID,
          type: 'circle',
          source: CONTEXT_SOURCE_ID,
          paint: {
            'circle-color': CONTEXT_POINT_COLOR,
            'circle-radius': WORKRECORD_POINT_RADIUS,
            'circle-opacity': CONTEXT_POINT_OPACITY,
            'circle-stroke-width': WORKRECORD_POINT_STROKE_WIDTH,
            'circle-stroke-color': WORKRECORD_POINT_STROKE_COLOR,
          },
          layout: {
            visibility: 'none',
          },
        });
        scheduleContextRefresh();
        // Guard against duplicate refresh handlers.
        map.off('moveend', scheduleContextRefresh);
        map.off('zoomend', scheduleContextRefresh);
        map.on('moveend', scheduleContextRefresh);
        map.on('zoomend', scheduleContextRefresh);
      }

      map.addSource('workrecords', {
        type: 'geojson',
        data: WORKRECORDS_GEOJSON_URL_WITH_PARAMS,
        cluster: true,
        clusterRadius: 25,
        clusterMaxZoom: 15,
      });
      map.addSource(CROWN_SOURCE_ID, {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] },
      });

      // Add crowns before marker layers so markers stay on top.
      map.addLayer({
        id: CROWN_FILL_LAYER_ID,
        type: 'fill',
        source: CROWN_SOURCE_ID,
        // Match HTML label overlay visibility to keep crowns in sync with labels.
        minzoom: LABEL_MIN_ZOOM,
        paint: {
          'fill-color': '#22c55e',
          'fill-opacity': 0.2,
        },
      });

      map.addLayer({
        id: CROWN_LINE_LAYER_ID,
        type: 'line',
        source: CROWN_SOURCE_ID,
        // Match HTML label overlay visibility to keep crowns in sync with labels.
        minzoom: LABEL_MIN_ZOOM,
        paint: {
          'line-color': '#16a34a',
          'line-width': 1,
          'line-opacity': 0.7,
        },
      });

      refreshProjectWorkrecords();
      // Guard against duplicate refresh handlers.
      map.off('moveend', scheduleWorkrecordsRefresh);
      map.off('zoomend', scheduleWorkrecordsRefresh);
      map.on('moveend', scheduleWorkrecordsRefresh);
      map.on('zoomend', scheduleWorkrecordsRefresh);

      map.addLayer({
        id: 'workrecord-clusters',
        type: 'circle',
        source: 'workrecords',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': '#1f6feb',
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            15,
            10, 20,
            30, 25,
          ],
          'circle-opacity': 0.85,
        },
      });

      map.addLayer({
        id: 'workrecord-cluster-count',
        type: 'symbol',
        source: 'workrecords',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': ['get', 'point_count_abbreviated'],
          'text-font': ['Open Sans Regular'],
          'text-size': 12,
        },
        paint: {
          'text-color': '#fff',
        },
      });

      map.addLayer({
        id: 'workrecord-unclustered',
        type: 'circle',
        source: 'workrecords',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': PROJECT_POINT_COLOR,
          'circle-radius': WORKRECORD_POINT_RADIUS,
          'circle-opacity': WORKRECORD_POINT_OPACITY,
          'circle-stroke-width': WORKRECORD_POINT_STROKE_WIDTH,
          'circle-stroke-color': WORKRECORD_POINT_STROKE_COLOR,
        },
      });

      map.addLayer({
        id: 'workrecord-hitarea',
        type: 'circle',
        source: 'workrecords',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#000000',
          'circle-opacity': 0,
          'circle-radius': 16,
        },
      });

      map.addSource('new-record-point', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] },
      });

      map.addLayer({
        id: 'new-record-point',
        type: 'circle',
        source: 'new-record-point',
        paint: {
          'circle-color': '#10b981',
          'circle-radius': 7,
          'circle-stroke-width': 2,
          'circle-stroke-color': '#fff',
        },
      });

      const expandCluster = (feature) => {
        if (!feature) return;
        const rawClusterId = feature.properties && feature.properties.cluster_id;
        const clusterId = rawClusterId !== undefined ? Number(rawClusterId) : null;
        if (clusterId === undefined || clusterId === null) return;
        const source = map.getSource('workrecords');
        if (!source || typeof source.getClusterExpansionZoom !== 'function') return;
        source.getClusterExpansionZoom(clusterId, (error, zoom) => {
          if (error) {
            console.error('MapLibre error', sanitizeErrorValue(error));
            return;
          }
          console.log('cluster click', clusterId, zoom);
          map.easeTo({
            center: feature.geometry.coordinates,
            zoom,
          });
        });
      };

      map.on('click', 'workrecord-clusters', (event) => {
        const features = map.queryRenderedFeatures(event.point, { layers: ['workrecord-clusters'] });
        const feature = features && features[0];
        if (!feature) return;
        expandCluster(feature);
      });

      const handleWorkRecordClick = (event, layers) => {
        const layerIds = Array.isArray(layers) ? layers : ['workrecord-unclustered'];
        const features = map.queryRenderedFeatures(event.point, { layers: layerIds });
        const feature = features && features[0];
        if (!feature) return;
        const recordId = feature.properties && feature.properties.id;
        const label = feature.properties && feature.properties.label;
        if (recordId && window.openWorkRecordPanel) {
          const layerId = feature.layer && feature.layer.id;
          const inProject = layerId ? layerId !== CONTEXT_LAYER_ID : undefined;
          window.openWorkRecordPanel(recordId, { label, inProject });
        }
      };

      map.on('click', 'workrecord-unclustered', (event) => {
        handleWorkRecordClick(event, ['workrecord-unclustered']);
      });
      map.on('click', 'workrecord-hitarea', (event) => {
        handleWorkRecordClick(event, ['workrecord-hitarea']);
      });
      if (projectParam) {
        map.on('click', CONTEXT_LAYER_ID, (event) => {
          handleWorkRecordClick(event, [CONTEXT_LAYER_ID]);
        });
      }

      const setPointer = () => { map.getCanvas().style.cursor = 'pointer'; };
      const resetPointer = () => { map.getCanvas().style.cursor = ''; };
      map.on('mouseenter', 'workrecord-clusters', setPointer);
      map.on('mouseleave', 'workrecord-clusters', resetPointer);
      map.on('mouseenter', 'workrecord-unclustered', setPointer);
      map.on('mouseleave', 'workrecord-unclustered', resetPointer);
      map.on('mouseenter', 'workrecord-hitarea', setPointer);
      map.on('mouseleave', 'workrecord-hitarea', resetPointer);
      if (projectParam) {
        map.on('mouseenter', CONTEXT_LAYER_ID, setPointer);
        map.on('mouseleave', CONTEXT_LAYER_ID, resetPointer);
      }
      map.on('click', (event) => {
        const bbox = [
          [event.point.x - HIT_TOLERANCE, event.point.y - HIT_TOLERANCE],
          [event.point.x + HIT_TOLERANCE, event.point.y + HIT_TOLERANCE],
        ];
        const clickLayers = projectParam
          ? ['workrecord-hitarea', 'workrecord-unclustered', CONTEXT_LAYER_ID]
          : ['workrecord-hitarea', 'workrecord-unclustered'];
        const unclustered = map.queryRenderedFeatures(bbox, { layers: clickLayers });
        if (unclustered && unclustered.length) {
          const recordId = unclustered[0].properties && unclustered[0].properties.id;
          const label = unclustered[0].properties && unclustered[0].properties.label;
          if (recordId && window.openWorkRecordPanel) {
            const layerId = unclustered[0].layer && unclustered[0].layer.id;
            const inProject = layerId ? layerId !== CONTEXT_LAYER_ID : undefined;
            window.openWorkRecordPanel(recordId, { label, inProject });
          }
          return;
        }
        const clusters = map.queryRenderedFeatures(bbox, { layers: ['workrecord-clusters'] });
        if (clusters && clusters.length) {
          expandCluster(clusters[0]);
          return;
        }
        const lngLat = event.lngLat;
        if (!lngLat) return;
        if (window.closeWorkRecordPanel) {
          window.closeWorkRecordPanel();
        }
        selectedLat = lngLat.lat.toFixed(7);
        selectedLon = lngLat.lng.toFixed(7);
        window.selectedLat = selectedLat;
        window.selectedLon = selectedLon;
        updateNewRecordMarker(lngLat);
        resetNewRecordForm();
      });
    });
    map.on('error', (e) => {
      const rawErr = e?.error || e;
      const err = sanitizeErrorValue(rawErr);
      const sourceId = rawErr && rawErr.sourceId;
      const extra = {
        sourceId,
        message: rawErr && rawErr.message,
        status: rawErr && rawErr.status,
        url: rawErr && rawErr.url ? sanitizeErrorValue(rawErr.url) : undefined,
      };
      if (sourceId === 'cz-labels') {
        console.warn('Vector labels unavailable', { ...extra, error: err });
        return;
      }
      console.error('MapLibre error', { ...extra, error: err });
    });

    map.addControl(
      new maplibregl.GeolocateControl({
        positionOptions: { enableHighAccuracy: true },
        trackUserLocation: true,
        showUserLocation: true,
        showAccuracyCircle: true,
        fitBoundsOptions: { maxZoom: 18 },
      }),
      'top-left'
    );
    map.addControl(new maplibregl.NavigationControl(), 'top-right');
  });
</script>
{% endblock %}
