{% extends "tracker/base.html" %}
{% block title %}MapLibre Pilot{% endblock %}
{% block content %}
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css">
<style>
  html, body { height: 100%; overflow: hidden; }
  body { margin: 0; background: #000; }
  nav.navbar,
  footer { display: none !important; }
  main.container { padding: 0 !important; max-width: none; }
  #map {
    position: fixed;
    inset: 0;
    z-index: 1;
  }
  #wr-label-overlay {
    position: fixed;
    inset: 0;
    z-index: 2;
    pointer-events: none;
    font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
  }
  .wr-label {
    position: absolute;
    font-size: 0.85rem;
    font-weight: 600;
    color: #111;
    text-shadow:
      0 0 4px rgba(255, 255, 255, 0.95),
      0 0 8px rgba(255, 255, 255, 0.75);
    white-space: nowrap;
    will-change: transform;
  }
</style>

<div id="map"></div>
<div id="wr-label-overlay"></div>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (!window.maplibregl) {
      console.error('MapLibre GL JS is not available.');
      return;
    }

    const API_KEY = "{{ mapy_key|default:'' }}";
    const WORKRECORDS_GEOJSON_URL = "{% url 'workrecords_geojson' %}";
    const LABEL_MIN_ZOOM = 17;
    const LABEL_LIMIT = 200;
    const labelOverlay = document.getElementById('wr-label-overlay');
    let workrecordFeatures = [];
    const sanitizeUrl = (value) => {
      if (typeof value !== 'string') return value;
      const [base] = value.split('?');
      return base;
    };
    const sanitizeErrorValue = (value) => {
      if (!value) return value;
      if (typeof value === 'string') {
        return value.replace(/([?&])apikey=[^&]+/gi, '$1apikey=***');
      }
      if (typeof value === 'object') {
        const clone = Array.isArray(value) ? [...value] : { ...value };
        if (clone.url) clone.url = sanitizeUrl(clone.url);
        if (clone.resource && typeof clone.resource === 'object' && clone.resource.url) {
          clone.resource = { ...clone.resource, url: sanitizeUrl(clone.resource.url) };
        }
        return clone;
      }
      return value;
    };

    const aerialTiles = `https://api.mapy.com/v1/maptiles/aerial/256/{z}/{x}/{y}?apikey=${API_KEY}`;
    const namesTiles = `https://api.mapy.com/v1/maptiles/names-overlay/256/{z}/{x}/{y}?apikey=${API_KEY}`;

    if (!API_KEY) {
      console.error('MapLibre error', 'Missing Mapy.com API key.');
    }
    console.log('Mapy tiles configured', {
      aerial: sanitizeUrl(aerialTiles),
      names: sanitizeUrl(namesTiles),
    });

    const style = {
      version: 8,
      sources: {
        'mapy-aerial': {
          type: 'raster',
          tiles: [aerialTiles],
          tileSize: 256,
          minzoom: 3,
          maxzoom: 20,
          attribution: '© <a href="https://mapy.cz/">Seznam.cz a.s.</a>',
        },
        'mapy-names': {
          type: 'raster',
          tiles: [namesTiles],
          tileSize: 256,
          minzoom: 3,
          maxzoom: 20,
          attribution: '© <a href="https://mapy.cz/">Seznam.cz a.s.</a>',
        },
      },
      layers: [
        {
          id: 'background',
          type: 'background',
          paint: { 'background-color': '#dde6f1' },
        },
        {
          id: 'mapy-aerial',
          type: 'raster',
          source: 'mapy-aerial',
        },
        {
          id: 'mapy-names',
          type: 'raster',
          source: 'mapy-names',
          paint: { 'raster-opacity': 1 },
        },
      ],
    };

    const map = new maplibregl.Map({
      container: 'map',
      style,
      center: [17.2509, 49.5938], // Olomouc
      zoom: 13,
    });

    const clearLabelOverlay = () => {
      if (!labelOverlay) return;
      if (typeof labelOverlay.replaceChildren === 'function') {
        labelOverlay.replaceChildren();
      } else {
        labelOverlay.innerHTML = '';
      }
    };

    const renderLabelOverlay = () => {
      if (!labelOverlay || !workrecordFeatures.length) {
        clearLabelOverlay();
        return;
      }
      const zoom = map.getZoom();
      if (Number.isFinite(zoom) && zoom < LABEL_MIN_ZOOM) {
        clearLabelOverlay();
        return;
      }
      const bounds = map.getBounds();
      const fragment = document.createDocumentFragment();
      let rendered = 0;
      for (const feature of workrecordFeatures) {
        if (!feature) continue;
        const coords = feature.coordinates;
        if (!Array.isArray(coords) || coords.length < 2) continue;
        const [lng, lat] = coords;
        if (!bounds || typeof bounds.contains !== 'function' || !bounds.contains([lng, lat])) {
          continue;
        }
        const labelText = feature.label || (feature.id ? `WR ${feature.id}` : '');
        if (!labelText) continue;
        const point = map.project([lng, lat]);
        const el = document.createElement('div');
        el.className = 'wr-label';
        el.textContent = labelText;
        el.style.transform = `translate(${point.x}px, ${point.y}px) translate(-50%, -130%)`;
        fragment.appendChild(el);
        rendered += 1;
        if (rendered >= LABEL_LIMIT) break;
      }
      if (typeof labelOverlay.replaceChildren === 'function') {
        labelOverlay.replaceChildren(fragment);
      } else {
        labelOverlay.innerHTML = '';
        labelOverlay.appendChild(fragment);
      }
    };

    map.on('move', renderLabelOverlay);
    map.on('zoom', renderLabelOverlay);
    map.on('rotate', renderLabelOverlay);

    map.on('load', () => {
      console.log('Map loaded');

      fetch(WORKRECORDS_GEOJSON_URL)
        .then(resp => resp.json())
        .then(fc => {
          const features = Array.isArray(fc && fc.features) ? fc.features : [];
          console.log('GeoJSON features:', features.length);
          console.log('Sample labels:', features.slice(0, 3).map(f => f && f.properties ? f.properties.label : null));
          workrecordFeatures = features
            .map(feature => {
              if (!feature || !feature.geometry || !feature.properties) return null;
              const coords = feature.geometry.coordinates;
              if (!Array.isArray(coords) || coords.length < 2) return null;
              return {
                id: feature.properties.id,
                label: feature.properties.label,
                coordinates: coords,
              };
            })
            .filter(Boolean);
          renderLabelOverlay();
        })
        .catch(err => console.error('GeoJSON debug error', err));

      map.addSource('workrecords', {
        type: 'geojson',
        data: WORKRECORDS_GEOJSON_URL,
        cluster: true,
        clusterRadius: 25,
        clusterMaxZoom: 15,
      });

      map.addLayer({
        id: 'workrecord-clusters',
        type: 'circle',
        source: 'workrecords',
        filter: ['has', 'point_count'],
        paint: {
          'circle-color': '#1f6feb',
          'circle-radius': [
            'step',
            ['get', 'point_count'],
            15,
            10, 20,
            30, 25,
          ],
          'circle-opacity': 0.85,
        },
      });

      map.addLayer({
        id: 'workrecord-cluster-count',
        type: 'symbol',
        source: 'workrecords',
        filter: ['has', 'point_count'],
        layout: {
          'text-field': ['get', 'point_count_abbreviated'],
          'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
          'text-size': 12,
        },
        paint: {
          'text-color': '#fff',
        },
      });

      map.addLayer({
        id: 'workrecord-unclustered',
        type: 'circle',
        source: 'workrecords',
        filter: ['!', ['has', 'point_count']],
        paint: {
          'circle-color': '#f97316',
          'circle-radius': 5,
          'circle-stroke-width': 1,
          'circle-stroke-color': '#fff',
        },
      });

      map.on('click', 'workrecord-clusters', (event) => {
        const features = map.queryRenderedFeatures(event.point, { layers: ['workrecord-clusters'] });
        const feature = features && features[0];
        if (!feature) return;
        const rawClusterId = feature.properties && feature.properties.cluster_id;
        const clusterId = rawClusterId !== undefined ? Number(rawClusterId) : null;
        if (clusterId === undefined || clusterId === null) return;
        const source = map.getSource('workrecords');
        if (!source || typeof source.getClusterExpansionZoom !== 'function') return;
        source.getClusterExpansionZoom(clusterId, (error, zoom) => {
          if (error) {
            console.error('MapLibre error', sanitizeErrorValue(error));
            return;
          }
          console.log('cluster click', clusterId, zoom);
          map.easeTo({
            center: feature.geometry.coordinates,
            zoom,
          });
        });
      });

      const handleWorkRecordClick = (event, layers) => {
        const layerIds = Array.isArray(layers) ? layers : ['workrecord-unclustered'];
        const features = map.queryRenderedFeatures(event.point, { layers: layerIds });
        const feature = features && features[0];
        if (!feature) return;
        const recordId = feature.properties && feature.properties.id;
        if (recordId) {
          alert(`WorkRecord ${recordId}`);
        }
      };

      map.on('click', 'workrecord-unclustered', (event) => {
        handleWorkRecordClick(event, ['workrecord-unclustered']);
      });

      const setPointer = () => { map.getCanvas().style.cursor = 'pointer'; };
      const resetPointer = () => { map.getCanvas().style.cursor = ''; };
      map.on('mouseenter', 'workrecord-clusters', setPointer);
      map.on('mouseleave', 'workrecord-clusters', resetPointer);
      map.on('mouseenter', 'workrecord-unclustered', setPointer);
      map.on('mouseleave', 'workrecord-unclustered', resetPointer);
    });
    map.on('error', (e) => {
      const err = sanitizeErrorValue(e?.error || e);
      console.error('MapLibre error', err);
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
  });
</script>
{% endblock %}
